{
    "type": "directory",
    "name": ".",
    "children": [
        {
            "type": "directory",
            "name": "api",
            "children": [
                {
                    "type": "file",
                    "name": "chat.js",
                    "content": "const { Configuration, OpenAIApi } = require('openai');\nconst { Client } = require('pg');\n\n\n// Inizializza la configurazione di OpenAI\nconst configuration = new Configuration({\n  apiKey: process.env.OPENAI_API_KEY, // Assicurati che la variabile d'ambiente sia impostata\n});\n\nconst openai = new OpenAIApi(configuration);\n\n// Configurazione del client PostgreSQL\nconst client = new Client({\n  connectionString: process.env.DATABASE_URL || 'postgres://default:8nCx5XIZurDd@ep-soft-tooth-a45f5lao-pooler.us-east-1.aws.neon.tech:5432/verceldb?sslmode=require'\n});\n\nclient.connect();\n\nmodule.exports = async (req, res) => {\n  if (req.method === 'POST') {\n    const { conversation_id, message, model } = req.body;\n\n\n    // Gestisci il caso in cui conversation_id non sia fornito (ad esempio, nuova conversazione)\n    let conversationId = conversation_id;\n\n    // Se conversationId non \u00e8 fornito, crea una nuova conversazione\n    if (!conversationId) {\n      try {\n        const result = await client.query(\n          'INSERT INTO conversations (conversation_name) VALUES ($1) RETURNING conversation_id',\n          ['Nuova Conversazione'] // Puoi personalizzare il nome della conversazione\n        );\n        conversationId = result.rows[0].conversation_id;\n      } catch (error) {\n        console.error('Errore nella creazione della nuova conversazione:', error);\n        res.status(500).json({ error: 'Errore interno del server' });\n        return;\n      }\n    }\n\n    // Recupera la cronologia dei messaggi per la conversazione corrente\n    let messages = [];\n    try {\n      messages = await getMessages(conversationId);\n    } catch (error) {\n      console.error('Errore nel recupero dei messaggi:', error);\n      res.status(500).json({ error: 'Errore interno del server' });\n      return;\n    }\n\n    // Aggiungi il messaggio dell'utente alla cronologia\n    messages.push({ role: 'user', content: message });\n\n    // Genera la risposta utilizzando l'API di OpenAI\n    try {\n      const completion = await openai.createChatCompletion({\n          model: model || 'o1-mini', // Usa il modello ricevuto o un predefinito\n          messages: messages,\n      });\n\n      const assistantMessage = completion.data.choices[0].message.content;\n\n      // Salva i messaggi nel database\n      await saveMessage(conversationId, 'user', message);\n      await saveMessage(conversationId, 'assistant', assistantMessage);\n\n      res.status(200).json({ conversation_id: conversationId, response: assistantMessage });\n    } catch (error) {\n      console.error(\n        'Errore nella chiamata all\\'API di OpenAI:',\n        error.response ? error.response.data : error.message\n      );\n      res.status(500).json({ error: 'Errore interno del server' });\n    }\n  } else {\n    res.status(405).json({ error: 'Metodo non consentito' });\n  }\n};\n\n// Funzione per ottenere i messaggi di una conversazione\nasync function getMessages(conversationId) {\n  const res = await client.query(\n    'SELECT role, content FROM messages WHERE conversation_id = $1 ORDER BY created_at ASC',\n    [conversationId]\n  );\n\n  // Mappa i messaggi nel formato richiesto dall'API di OpenAI\n  return res.rows.map((row) => ({\n    role: row.role,\n    content: row.content,\n  }));\n}\n\n// Funzione per salvare un messaggio nel database\nasync function saveMessage(conversationId, role, content) {\n  await client.query(\n    'INSERT INTO messages (conversation_id, role, content) VALUES ($1, $2, $3)',\n    [conversationId, role, content]\n  );\n}"
                },
                {
                    "type": "file",
                    "name": "conversations.js",
                    "content": "const { Client } = require('pg');\n\n// Configurazione del client PostgreSQL\nconst client = new Client({\n    connectionString: process.env.DATABASE_URL || 'postgres://default:8nCx5XIZurDd@ep-soft-tooth-a45f5lao-pooler.us-east-1.aws.neon.tech:5432/verceldb?sslmode=require'\n});\n\nclient.connect();\n\nmodule.exports = async (req, res) => {\n    if (req.method === 'GET') {\n        // Se viene passato un ID, ritorna la conversazione specifica\n        if (req.query.id) {\n            const conversationId = req.query.id;\n            const messagesRes = await client.query(\n                'SELECT role, content FROM messages WHERE conversation_id = $1 ORDER BY created_at ASC',\n                [conversationId]\n            );\n            res.status(200).json({ messages: messagesRes.rows });\n        } else {\n            // Altrimenti, ritorna tutte le conversazioni\n            const conversationsRes = await client.query(\n                'SELECT conversation_id, conversation_name FROM conversations ORDER BY created_at DESC'\n            );\n            res.status(200).json(conversationsRes.rows);\n        }\n    } else if (req.method === 'POST') {\n        const { conversation_name } = req.body;\n        const insertRes = await client.query(\n            'INSERT INTO conversations (conversation_name) VALUES ($1) RETURNING conversation_id',\n            [conversation_name]\n        );\n        const conversationId = insertRes.rows[0].conversation_id;\n        res.status(201).json({ conversation_id: conversationId });\n    } else if (req.method === 'DELETE') {\n        const conversationId = req.query.id;\n        if (!conversationId) {\n            res.status(400).json({ error: 'ID conversazione mancante' });\n            return;\n        }\n\n        try {\n            // Elimina i messaggi associati alla conversazione\n            await client.query('DELETE FROM messages WHERE conversation_id = $1', [conversationId]);\n\n            // Elimina la conversazione\n            await client.query('DELETE FROM conversations WHERE conversation_id = $1', [conversationId]);\n\n            res.status(200).json({ message: 'Conversazione eliminata con successo' });\n        } catch (error) {\n            console.error('Errore nell\\'eliminazione della conversazione:', error);\n            res.status(500).json({ error: 'Errore interno del server' });\n        }\n    } else {\n        res.status(405).json({ error: 'Metodo non consentito' });\n    }\n};"
                }
            ]
        },
        {
            "type": "file",
            "name": "backup.text",
            "content": "document.addEventListener('DOMContentLoaded', () => {\n    const chatWindow = document.getElementById('chat-window');\n    const sendButton = document.getElementById('send-button');\n    const userInput = document.getElementById('user-input');\n    const conversationsList = document.getElementById('conversations');\n    const newConversationButton = document.getElementById('new-conversation');\n\n    let currentConversationId = null;\n\n    // Funzione per caricare le conversazioni esistenti\n    function loadConversations() {\n        fetch('/api/conversations')\n            .then(response => response.json())\n            .then(data => {\n                conversationsList.innerHTML = '';\n                data.forEach(conv => {\n                    const li = document.createElement('li');\n                    li.textContent = conv.conversation_name;\n                    li.dataset.id = conv.conversation_id;\n                    li.classList.add('conversation-item');\n\n                    // Aggiungi listener per selezionare la conversazione\n                    li.addEventListener('click', () => {\n                        currentConversationId = conv.conversation_id;\n                        loadConversation(conv.conversation_id);\n                        updateActiveConversation(conv.conversation_id);\n                    });\n\n                    // Creazione del pulsante di eliminazione\n                    const deleteButton = document.createElement('button');\n                    deleteButton.textContent = '\u2715';\n                    deleteButton.classList.add('delete-button');\n\n                    // Prevenire la propagazione del click sul pulsante di eliminazione\n                    deleteButton.addEventListener('click', (e) => {\n                        e.stopPropagation();\n                        deleteConversation(conv.conversation_id, conv.conversation_name);\n                    });\n\n                    li.appendChild(deleteButton);\n                    conversationsList.appendChild(li);\n                });\n\n                // Aggiorna l'evidenziazione della conversazione attiva\n                updateActiveConversation(currentConversationId);\n            })\n            .catch(error => console.error('Errore nel caricamento delle conversazioni:', error));\n    }\n\n    // Funzione per aggiornare l'evidenziazione della conversazione attiva\n    function updateActiveConversation(conversationId) {\n        const conversationItems = document.querySelectorAll('.conversation-item');\n        conversationItems.forEach(item => {\n            if (parseInt(item.dataset.id) === conversationId) {\n                item.classList.add('active');\n            } else {\n                item.classList.remove('active');\n            }\n        });\n    }\n\n    // Funzione per eliminare una conversazione\n    function deleteConversation(conversationId, conversationName) {\n        const confirmDelete = confirm(`Sei sicuro di voler eliminare la conversazione \"${conversationName}\"?`);\n        if (confirmDelete) {\n            fetch(`/api/conversations?id=${conversationId}`, {\n                method: 'DELETE',\n            })\n                .then(response => {\n                    if (response.ok) {\n                        // Se la conversazione eliminata era quella attiva, resetta la chat\n                        if (currentConversationId === conversationId) {\n                            currentConversationId = null;\n                            chatWindow.innerHTML = '';\n                        }\n                        loadConversations();\n                    } else {\n                        console.error('Errore nell\\'eliminazione della conversazione.');\n                    }\n                })\n                .catch(error => console.error('Errore nella comunicazione con l\\'API:', error));\n        }\n    }\n\n    // Funzione per caricare una conversazione specifica\n    function loadConversation(conversationId) {\n        fetch(`/api/conversations?id=${conversationId}`)\n            .then(response => response.json())\n            .then(data => {\n                chatWindow.innerHTML = '';\n                data.messages.forEach(msg => {\n                    displayMessage(msg.role, msg.content);\n                });\n            })\n            .catch(error => console.error('Errore nel caricamento della conversazione:', error));\n    }\n\n\n\n\n\n\n\n\n    // Funzione per formattare il testo racchiuso tra **<testo>** in grassetto\n    function formatBoldText(text) {\n        const boldRegex = /\\*\\*(.*?)\\*\\*/g;\n        const formattedText = text.replace(boldRegex, '<strong class=\"highlighted-text\">$1</strong>');\n        // Applica la formattazione corsiva dopo aver applicato il grassetto\n        return formatItalicText(formattedText);\n    }\n\n    // Funzione per formattare il testo racchiuso tra `testo` in corsivo\n    function formatItalicText(text) {\n        const italicRegex = /`([^`]+)`/g;\n        return text.replace(italicRegex, '<em>$1</em>');\n    }\n\n\n\n\n\n    // Funzione per visualizzare un messaggio\n    function displayMessage(role, content) {\n        const messageDiv = document.createElement('div');\n        messageDiv.classList.add('message', role);\n    \n        const contentDiv = document.createElement('div');\n        contentDiv.classList.add('content');\n    \n        // Suddividi il contenuto in parti\n        const messageParts = parseMessageContent(content);\n    \n        messageParts.forEach(part => {\n            if (part.type === 'code') {\n                const pre = document.createElement('pre');\n                const code = document.createElement('code');\n                code.classList.add(part.language || 'plaintext');\n    \n                // Assegna il contenuto del codice\n                code.textContent = part.code.trim(); // Usa textContent per evitare l'inserimento di HTML\n    \n                pre.appendChild(code);\n    \n                // Crea il pulsante di copia\n                const copyButton = document.createElement('button');\n                copyButton.textContent = 'Copia';\n                copyButton.classList.add('copy-button');\n    \n                copyButton.addEventListener('click', () => {\n                    // Copia il codice negli appunti\n                    const codeText = part.code.trim();\n                    navigator.clipboard.writeText(codeText).then(() => {\n                        // Fornisci un feedback all'utente\n                        copyButton.textContent = 'Copiato!';\n                        setTimeout(() => {\n                            copyButton.textContent = 'Copia';\n                        }, 2000);\n                    }).catch(err => {\n                        console.error('Errore nel copiare il codice:', err);\n                    });\n                });\n    \n                pre.appendChild(copyButton);\n                contentDiv.appendChild(pre);\n    \n                // Inizializza Highlight.js sul blocco di codice\n                hljs.highlightElement(code);\n                // Inizializza i numeri di riga\n                hljs.lineNumbersBlock(code);\n            } else if (part.type === 'separator') {\n                const separatorDiv = document.createElement('div');\n                separatorDiv.classList.add('separator');\n                contentDiv.appendChild(separatorDiv);\n            } else if (part.type === 'title') {\n                const titleElement = document.createElement('div');\n                titleElement.classList.add('message-title', `title-level-${part.level}`);\n                titleElement.innerHTML = formatBoldText(part.text);\n                contentDiv.appendChild(titleElement);\n            } else {\n                const textParagraph = document.createElement('p');\n                textParagraph.innerHTML = formatBoldText(part.text.trim());\n                contentDiv.appendChild(textParagraph);\n            }\n        });\n    \n        messageDiv.appendChild(contentDiv);\n        chatWindow.appendChild(messageDiv);\n    \n        // Scrolla la chat per mostrare il nuovo messaggio\n        messageDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });\n    }\n\n    // Funzione per verificare se il messaggio contiene un blocco di codice\n    function isCodeBlock(text) {\n        return /```[\\s\\S]*```/.test(text);\n    }\n\n    // Funzione per estrarre il codice e la lingua dal blocco di codice\n    function extractCode(text) {\n        const regex = /```(\\w+)?\\n([\\s\\S]*?)```/g;\n        const matches = regex.exec(text);\n        return {\n            language: matches[1] || '',\n            code: matches[2] || text\n        };\n    }\n\n\n    // Variabile per il loading indicator\nlet loadingIndicator = null;\n\n// Funzione per mostrare l'animazione di caricamento\nfunction showLoading() {\n    // Crea il loading indicator se non esiste\n    if (!loadingIndicator) {\n        loadingIndicator = document.createElement('div');\n        loadingIndicator.classList.add('loading-indicator');\n        loadingIndicator.innerHTML = `<span>Caricamento...</span>`;\n    }\n\n    // Aggiungi il loading indicator al chatWindow\n    chatWindow.appendChild(loadingIndicator);\n\n    // Scorri la chat fino alla fine per mostrare il loading indicator\n    loadingIndicator.scrollIntoView({ behavior: 'smooth', block: 'start' });\n}\n\n// Funzione per nascondere l'animazione di caricamento\nfunction hideLoading() {\n    if (loadingIndicator) {\n        chatWindow.removeChild(loadingIndicator);\n        loadingIndicator = null; // Resetta la variabile\n    }\n}\n\n    // Gestione dell'invio del messaggio\n    sendButton.addEventListener('click', () => {\n        const message = userInput.value.trim();\n        if (message === '') return;\n\n        displayMessage('user', message);\n        userInput.value = '';\n\n        showLoading(); // Mostra l'animazione di caricamento dopo aver visualizzato il messaggio dell'utente\n\n        fetch('/api/chat', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                conversation_id: currentConversationId,\n                message: message\n            })\n        })\n        .then(response => response.json())\n        .then(data => {\n            currentConversationId = data.conversation_id;\n            hideLoading(); // Nasconde l'animazione una volta ricevuta la risposta\n            displayMessage('assistant', data.response);\n        })\n        .catch(error => {\n            console.error('Errore nella comunicazione con l\\'API:', error);\n            hideLoading(); // Nasconde l'animazione anche in caso di errore\n        });\n    });\n\n    // Creazione di una nuova conversazione\n    newConversationButton.addEventListener('click', () => {\n        const conversationName = prompt('Inserisci un nome per la nuova conversazione:');\n        if (conversationName) {\n            fetch('/api/conversations', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({ conversation_name: conversationName })\n            })\n                .then(response => response.json())\n                .then(data => {\n                    currentConversationId = data.conversation_id;\n                    chatWindow.innerHTML = '';\n                    loadConversations();\n                })\n                .catch(error => console.error('Errore nella creazione della conversazione:', error));\n        }\n    });\n\n    // Carica le conversazioni all'avvio\n    loadConversations();\n\n    // Funzione per suddividere il testo in parti di testo e separatori\n    function parseMessageContent(content) {\n        const codeRegex = /```(\\w*)\\s*\\n?([\\s\\S]*?)\\n?```/g;\n        const parts = [];\n        let lastIndex = 0;\n        let match;\n    \n        while ((match = codeRegex.exec(content)) !== null) {\n            // Testo prima del blocco di codice\n            if (match.index > lastIndex) {\n                const textBefore = content.substring(lastIndex, match.index);\n                parseTextParts(textBefore, parts);\n            }\n    \n            // Blocco di codice\n            parts.push({\n                type: 'code',\n                language: match[1] || '',\n                code: match[2]\n            });\n    \n            lastIndex = codeRegex.lastIndex;\n        }\n    \n        // Testo dopo l'ultimo blocco di codice\n        if (lastIndex < content.length) {\n            const textAfter = content.substring(lastIndex);\n            parseTextParts(textAfter, parts);\n        }\n    \n        return parts;\n    }\n    \n    // Funzione per suddividere il testo in parti di testo, separatori e titoli\n    function parseTextParts(text, parts) {\n        const separatorRegex = /^---$/gm;\n        const titleRegex = /^(#{1,3})\\s*(.*)$/gm;\n        let lastIndex = 0;\n        let match;\n    \n        while ((match = titleRegex.exec(text)) !== null) {\n            // Testo prima del titolo\n            if (match.index > lastIndex) {\n                const precedingText = text.substring(lastIndex, match.index);\n                parseSeparatorsAndText(precedingText, parts);\n            }\n    \n            // Aggiungi il titolo con il livello\n            const level = match[1].length; // Numero di '#'\n            const titleText = match[2].trim();\n    \n            parts.push({\n                type: 'title',\n                level: level,\n                text: titleText\n            });\n    \n            lastIndex = titleRegex.lastIndex;\n        }\n    \n        // Testo dopo l'ultimo titolo\n        if (lastIndex < text.length) {\n            const remainingText = text.substring(lastIndex);\n            parseSeparatorsAndText(remainingText, parts);\n        }\n    }\n    \n    // Funzione per suddividere il testo in separatori e testo normale\n    function parseSeparatorsAndText(text, parts) {\n        const separatorRegex = /^---$/gm;\n        let lastIndex = 0;\n        let match;\n    \n        while ((match = separatorRegex.exec(text)) !== null) {\n            // Testo prima del separatore\n            if (match.index > lastIndex) {\n                parts.push({\n                    type: 'text',\n                    text: text.substring(lastIndex, match.index)\n                });\n            }\n            // Aggiungi il separatore\n            parts.push({ type: 'separator' });\n            lastIndex = separatorRegex.lastIndex;\n        }\n    \n        // Testo dopo l'ultimo separatore\n        if (lastIndex < text.length) {\n            parts.push({\n                type: 'text',\n                text: text.substring(lastIndex)\n            });\n        }\n    }\n\n\n    \n});\n\n\n"
        },
        {
            "type": "file",
            "name": "index.html",
            "content": "<!DOCTYPE html>\n<html lang=\"it\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Chatbot AI</title>\n    <link rel=\"stylesheet\" href=\"styles.css\">\n    <!-- Includi Highlight.js per la sintassi evidenziata -->\n    <link rel=\"stylesheet\" href=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github-dark.min.css\">\n</head>\n<body>\n    <div class=\"chat-container\">\n        <header>\n            <h1>o1-preview | <span>assistenti custom</span></h1>\n            <!-- Aggiungi il selettore del modello -->\n            <div class=\"model-selector\">\n                <label for=\"model-select\">Modello:</label>\n                <select id=\"model-select\">\n                    <option value=\"o1-mini\">o1-mini</option>\n                    <option value=\"o1-preview\">o1-preview</option>\n                    <option value=\"gpt-3.5-turbo\">gpt-4o</option>\n                    <!-- Aggiungi altri modelli se necessario -->\n                </select>\n            </div>\n        </header>\n        <div id=\"conversation-list\">\n            <h2>Conversazioni</h2>\n            <ul id=\"conversations\"></ul>\n            <button id=\"new-conversation\">+ Nuova Conversazione</button>\n        </div>\n        <div id=\"chat-section\">\n            <div id=\"chat-window\"></div>\n            <div class=\"input-area\">\n                <textarea id=\"user-input\" placeholder=\"Scrivi un messaggio...\"></textarea>\n                <button id=\"send-button\">Invia</button>\n            </div>\n        </div>\n    </div>\n\n    <!-- Include le librerie di Highlight.js -->\n    <script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js\"></script>\n    <!-- Includi i linguaggi che desideri supportare -->\n    <script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js\"></script>\n    <script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js\"></script>\n    <script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/html.min.js\"></script>\n    <script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/css.min.js\"></script>\n    <script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/php.min.js\"></script>\n    <script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/json.min.js\"></script>\n    <script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/java.min.js\"></script>\n    <script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/csharp.min.js\"></script>\n    <script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/ruby.min.js\"></script>\n    <script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/sql.min.js\"></script>\n\n    \n    <link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.css\">\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.1.6/purify.min.js\" integrity=\"sha512-jB0TkTBeQC9ZSkBqDhdmfTv1qdfbWpGE72yJ/01Srq6hEzZIz2xkz1e57p9ai7IeHMwEG7HpzG6NdptChif5Pg==\" crossorigin=\"anonymous\" referrerpolicy=\"no-referrer\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js\"></script>\n    <!-- Il tuo script principale -->\n    <script type=\"module\" src=\"script.js\"></script>\n</html>"
        },
        {
            "type": "file",
            "name": "package.json",
            "content": "{\n    \"name\": \"o1-private-assistant\",\n    \"version\": \"1.0.0\",\n    \"description\": \"Un'applicazione chatbot AI con OpenAI API, salvata in PostgreSQL e deployata su Vercel.\",\n    \"main\": \"index.js\",\n    \"scripts\": {\n      \"dev\": \"vercel dev\",\n      \"start\": \"vercel start\"\n    },\n    \"author\": \"Il tuo nome\",\n    \"license\": \"MIT\",\n    \"dependencies\": {\n      \"openai\": \"^3.2.1\",\n      \"pg\": \"^8.10.0\",\n      \"highlight.js\": \"^11.7.0\",\n      \"dompurify\": \"^2.4.0\"\n    },\n    \"devDependencies\": {\n      \"nodemon\": \"^2.0.22\"\n    }\n  }"
        },
        {
            "type": "file",
            "name": "script.js",
            "content": "document.addEventListener('DOMContentLoaded', () => {\n    const chatWindow = document.getElementById('chat-window');\n    const sendButton = document.getElementById('send-button');\n    const userInput = document.getElementById('user-input');\n    const conversationsList = document.getElementById('conversations');\n    const newConversationButton = document.getElementById('new-conversation');\n\n    let currentConversationId = null;\n\n    let selectedModel = 'o1-mini'; // Imposta un modello predefinito\n\n    const modelSelect = document.getElementById('model-select');\n\n    // Aggiorna il modello selezionato quando l'utente cambia la selezione\n    modelSelect.addEventListener('change', () => {\n        selectedModel = modelSelect.value;\n    });\n\n    // Funzione per caricare le conversazioni esistenti\n    function loadConversations() {\n        fetch('/api/conversations')\n            .then(response => response.json())\n            .then(data => {\n                conversationsList.innerHTML = '';\n                data.forEach(conv => {\n                    const li = document.createElement('li');\n                    li.textContent = conv.conversation_name;\n                    li.dataset.id = conv.conversation_id;\n                    li.classList.add('conversation-item');\n\n                    // Aggiungi listener per selezionare la conversazione\n                    li.addEventListener('click', () => {\n                        currentConversationId = conv.conversation_id;\n                        loadConversation(conv.conversation_id);\n                        updateActiveConversation(conv.conversation_id);\n                    });\n\n                    // Creazione del pulsante di eliminazione\n                    const deleteButton = document.createElement('button');\n                    deleteButton.textContent = '\u2715';\n                    deleteButton.classList.add('delete-button');\n\n                    // Prevenire la propagazione del click sul pulsante di eliminazione\n                    deleteButton.addEventListener('click', (e) => {\n                        e.stopPropagation();\n                        deleteConversation(conv.conversation_id, conv.conversation_name);\n                    });\n\n                    li.appendChild(deleteButton);\n                    conversationsList.appendChild(li);\n                });\n\n                // Aggiorna l'evidenziazione della conversazione attiva\n                updateActiveConversation(currentConversationId);\n            })\n            .catch(error => console.error('Errore nel caricamento delle conversazioni:', error));\n    }\n\n    // Funzione per aggiornare l'evidenziazione della conversazione attiva\n    function updateActiveConversation(conversationId) {\n        const conversationItems = document.querySelectorAll('.conversation-item');\n        conversationItems.forEach(item => {\n            if (parseInt(item.dataset.id) === conversationId) {\n                item.classList.add('active');\n            } else {\n                item.classList.remove('active');\n            }\n        });\n    }\n\n    // Funzione per eliminare una conversazione\n    function deleteConversation(conversationId, conversationName) {\n        const confirmDelete = confirm(`Sei sicuro di voler eliminare la conversazione \"${conversationName}\"?`);\n        if (confirmDelete) {\n            fetch(`/api/conversations?id=${conversationId}`, {\n                method: 'DELETE',\n            })\n                .then(response => {\n                    if (response.ok) {\n                        // Se la conversazione eliminata era quella attiva, resetta la chat\n                        if (currentConversationId === conversationId) {\n                            currentConversationId = null;\n                            chatWindow.innerHTML = '';\n                        }\n                        loadConversations();\n                    } else {\n                        console.error('Errore nell\\'eliminazione della conversazione.');\n                    }\n                })\n                .catch(error => console.error('Errore nella comunicazione con l\\'API:', error));\n        }\n    }\n\n    // Funzione per caricare una conversazione specifica\n    function loadConversation(conversationId) {\n        fetch(`/api/conversations?id=${conversationId}`)\n            .then(response => response.json())\n            .then(data => {\n                chatWindow.innerHTML = '';\n                data.messages.forEach(msg => {\n                    displayMessage(msg.role, msg.content);\n                });\n            })\n            .catch(error => console.error('Errore nel caricamento della conversazione:', error));\n    }\n\n\n\n\n\n\n\n\n    // Funzione per formattare il testo racchiuso tra **<testo>** in grassetto\n    function formatBoldText(text) {\n        const boldRegex = /\\*\\*(.*?)\\*\\*/g;\n        const formattedText = text.replace(boldRegex, '<strong class=\"highlighted-text\">$1</strong>');\n        // Applica la formattazione corsiva dopo aver applicato il grassetto\n        return formatItalicText(formattedText);\n    }\n\n    // Funzione per formattare il testo racchiuso tra `testo` in corsivo\n    function formatItalicText(text) {\n        const italicRegex = /`([^`]+)`/g;\n        return text.replace(italicRegex, '<em>$1</em>');\n    }\n\n\n\n\n\n    // Funzione per visualizzare un messaggio\n    function displayMessage(role, content) {\n        const messageDiv = document.createElement('div');\n        messageDiv.classList.add('message', role);\n        const contentDiv = document.createElement('div');\n        contentDiv.classList.add('content');\n      \n        if (role === 'assistant') {\n          // Applica la formattazione solo ai messaggi dell'assistente\n          // Suddividi il contenuto in parti\n          const messageParts = parseMessageContent(content);\n          messageParts.forEach(part => {\n            if (part.type === 'code') {\n              const pre = document.createElement('pre');\n              const code = document.createElement('code');\n              code.classList.add(part.language || 'plaintext');\n              code.textContent = part.code.trim();\n              pre.appendChild(code);\n      \n              // Crea il pulsante di copia\n              const copyButton = document.createElement('button');\n              copyButton.textContent = 'Copia';\n              copyButton.classList.add('copy-button');\n              copyButton.addEventListener('click', () => {\n                const codeText = part.code.trim();\n                navigator.clipboard.writeText(codeText).then(() => {\n                  copyButton.textContent = 'Copiato!';\n                  setTimeout(() => {\n                    copyButton.textContent = 'Copia';\n                  }, 2000);\n                }).catch(err => {\n                  console.error('Errore nel copiare il codice:', err);\n                });\n              });\n              pre.appendChild(copyButton);\n              contentDiv.appendChild(pre);\n      \n              // Inizializza Highlight.js sul blocco di codice\n              hljs.highlightElement(code);\n              // Inizializza i numeri di riga\n              hljs.lineNumbersBlock(code);\n            } else if (part.type === 'separator') {\n              const separatorDiv = document.createElement('div');\n              separatorDiv.classList.add('separator');\n              contentDiv.appendChild(separatorDiv);\n            } else if (part.type === 'title') {\n                const titleElement = document.createElement('div');\n                titleElement.classList.add('message-title', `title-level-${part.level}`);\n                // Usa DOMPurify per sanitizzare l'HTML\n                titleElement.innerHTML = DOMPurify.sanitize(formatBoldText(part.text));\n                contentDiv.appendChild(titleElement);\n            } else {\n                const textParagraph = document.createElement('p');\n                // Usa DOMPurify per sanitizzare l'HTML\n                textParagraph.innerHTML = DOMPurify.sanitize(formatBoldText(part.text.trim()));\n                contentDiv.appendChild(textParagraph);\n            }\n        });\n        } else {\n          // Per i messaggi dell'utente, mostra il testo senza formattazione\n          const textParagraph = document.createElement('p');\n          textParagraph.textContent = content.trim();\n          contentDiv.appendChild(textParagraph);\n        }\n      \n        messageDiv.appendChild(contentDiv);\n        chatWindow.appendChild(messageDiv);\n      \n        // Scrolla la chat per mostrare il nuovo messaggio\n        messageDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });\n      }\n\n    // Funzione per verificare se il messaggio contiene un blocco di codice\n    function isCodeBlock(text) {\n        return /```[\\s\\S]*```/.test(text);\n    }\n\n    // Funzione per estrarre il codice e la lingua dal blocco di codice\n    function extractCode(text) {\n        const regex = /```(\\w+)?\\n([\\s\\S]*?)```/g;\n        const matches = regex.exec(text);\n        return {\n            language: matches[1] || '',\n            code: matches[2] || text\n        };\n    }\n\n\n    // Variabile per il loading indicator\nlet loadingIndicator = null;\n\n// Funzione per mostrare l'animazione di caricamento\nfunction showLoading() {\n    // Crea il loading indicator se non esiste\n    if (!loadingIndicator) {\n        loadingIndicator = document.createElement('div');\n        loadingIndicator.classList.add('loading-indicator');\n        loadingIndicator.innerHTML = `<span>Caricamento...</span>`;\n    }\n\n    // Aggiungi il loading indicator al chatWindow\n    chatWindow.appendChild(loadingIndicator);\n\n    // Scorri la chat fino alla fine per mostrare il loading indicator\n    loadingIndicator.scrollIntoView({ behavior: 'smooth', block: 'start' });\n}\n\n// Funzione per nascondere l'animazione di caricamento\nfunction hideLoading() {\n    if (loadingIndicator) {\n        chatWindow.removeChild(loadingIndicator);\n        loadingIndicator = null; // Resetta la variabile\n    }\n}\n\n    // Gestione dell'invio del messaggio\n    sendButton.addEventListener('click', () => {\n        const message = userInput.value.trim();\n        if (message === '') return;\n\n        displayMessage('user', message);\n        userInput.value = '';\n\n        showLoading(); // Mostra l'animazione di caricamento\n\n        fetch('/api/chat', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                conversation_id: currentConversationId,\n                message: message,\n                model: selectedModel // Includi il modello selezionato nella richiesta\n            })\n        })\n        .then(response => response.json())\n        .then(data => {\n            currentConversationId = data.conversation_id;\n            hideLoading(); // Nasconde l'animazione una volta ricevuta la risposta\n            displayMessage('assistant', data.response);\n        })\n        .catch(error => {\n            console.error('Errore nella comunicazione con l\\'API:', error);\n            hideLoading(); // Nasconde l'animazione anche in caso di errore\n        });\n    });\n\n    // Creazione di una nuova conversazione\n    newConversationButton.addEventListener('click', () => {\n        const conversationName = prompt('Inserisci un nome per la nuova conversazione:');\n        if (conversationName) {\n            fetch('/api/conversations', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({ conversation_name: conversationName })\n            })\n                .then(response => response.json())\n                .then(data => {\n                    currentConversationId = data.conversation_id;\n                    chatWindow.innerHTML = '';\n                    loadConversations();\n                })\n                .catch(error => console.error('Errore nella creazione della conversazione:', error));\n        }\n    });\n\n    // Carica le conversazioni all'avvio\n    loadConversations();\n\n    // Funzione per suddividere il testo in parti di testo e separatori\n    function parseMessageContent(content) {\n        const codeRegex = /```(\\w*)\\s*\\n?([\\s\\S]*?)\\n?```/g;\n        const parts = [];\n        let lastIndex = 0;\n        let match;\n    \n        while ((match = codeRegex.exec(content)) !== null) {\n            // Testo prima del blocco di codice\n            if (match.index > lastIndex) {\n                const textBefore = content.substring(lastIndex, match.index);\n                parseTextParts(textBefore, parts);\n            }\n    \n            // Blocco di codice\n            parts.push({\n                type: 'code',\n                language: match[1] || '',\n                code: match[2]\n            });\n    \n            lastIndex = codeRegex.lastIndex;\n        }\n    \n        // Testo dopo l'ultimo blocco di codice\n        if (lastIndex < content.length) {\n            const textAfter = content.substring(lastIndex);\n            parseTextParts(textAfter, parts);\n        }\n    \n        return parts;\n    }\n    \n    // Funzione per suddividere il testo in parti di testo, separatori e titoli\n    function parseTextParts(text, parts) {\n        const separatorRegex = /^---$/gm;\n        const titleRegex = /^(#{1,3})\\s*(.*)$/gm;\n        let lastIndex = 0;\n        let match;\n    \n        while ((match = titleRegex.exec(text)) !== null) {\n            // Testo prima del titolo\n            if (match.index > lastIndex) {\n                const precedingText = text.substring(lastIndex, match.index);\n                parseSeparatorsAndText(precedingText, parts);\n            }\n    \n            // Aggiungi il titolo con il livello\n            const level = match[1].length; // Numero di '#'\n            const titleText = match[2].trim();\n    \n            parts.push({\n                type: 'title',\n                level: level,\n                text: titleText\n            });\n    \n            lastIndex = titleRegex.lastIndex;\n        }\n    \n        // Testo dopo l'ultimo titolo\n        if (lastIndex < text.length) {\n            const remainingText = text.substring(lastIndex);\n            parseSeparatorsAndText(remainingText, parts);\n        }\n    }\n    \n    // Funzione per suddividere il testo in separatori e testo normale\n    function parseSeparatorsAndText(text, parts) {\n        const separatorRegex = /^---$/gm;\n        let lastIndex = 0;\n        let match;\n    \n        while ((match = separatorRegex.exec(text)) !== null) {\n            // Testo prima del separatore\n            if (match.index > lastIndex) {\n                parts.push({\n                    type: 'text',\n                    text: text.substring(lastIndex, match.index)\n                });\n            }\n            // Aggiungi il separatore\n            parts.push({ type: 'separator' });\n            lastIndex = separatorRegex.lastIndex;\n        }\n    \n        // Testo dopo l'ultimo separatore\n        if (lastIndex < text.length) {\n            parts.push({\n                type: 'text',\n                text: text.substring(lastIndex)\n            });\n        }\n    }\n\n\n    \n});\n\n\n"
        },
        {
            "type": "file",
            "name": "styles.css",
            "content": "body {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    background-color: #f0f2f5;\n    margin: 0;\n    padding: 0;\n}\n\n.chat-container {\n    display: flex;\n    height: 100vh;\n}\n\nheader {\n    display: flex;\n    position: fixed;\n    justify-content: center;\n    height: 8vh;\n    width: 100%;\n    border-bottom: 2px solid rgb(0, 0, 0);\n    background: linear-gradient(135deg, rgb(39, 39, 76), rgb(88, 0, 88) 70%);\n    color: white;\n    z-index: 1;\n}\n\nheader h1 {\n    margin-top: auto;\n    margin-bottom: auto;\n}\n\n/* header span{\n    color: #57ff5c;\n} */\n\n#conversation-list {\n    box-sizing: border-box;\n    width: 20%;\n    background-color: #242526;\n    color: #e4e6eb;\n    overflow-y: auto;\n    overflow-x: hidden;\n    padding: 20px 20px 20px; /* Aggiustamento padding per spazio sotto l'header */\n    margin-top: 8vh;\n}\n\n\n#conversation-list h2 {\n    margin-top: 0;\n    color: #e4e6eb;\n}\n\n#conversation-list ul {\n    list-style-type: none;\n    padding: 0;\n    margin-top: 20px;\n}\n\n#conversation-list li {\n    padding: 10px;\n    cursor: pointer;\n    border-bottom: 1px solid #3A3B3C;\n}\n\n#conversation-list li:hover, #conversation-list li.active {\n    background-color: #3A3B3C;\n}\n\n#new-conversation {\n    margin-top: 20px;\n    width: 100%;\n    padding: 10px;\n    background-color: #4CAF50;\n    border: none;\n    color: white;\n    font-size: 16px;\n    cursor: pointer;\n    border-radius: 6px;\n}\n\n#chat-section {\n    width: 80%;\n    display: flex;\n    flex-direction: column;\n    padding-top: 15px; /* Aggiustamento padding per spazio sotto l'header */\n    padding-left: 30px; /* Aggiustamento padding per spazio sotto l'header */\n    padding-right: 30px; /* Aggiustamento padding per spazio sotto l'header */\n    border-radius: 10px;\n    margin-top: 8vh;\n    position: relative;\n}\n\n#chat-window {\n    flex-grow: 1;\n    padding: 20px;\n    overflow-y: auto;\n    background-color: #fff;\n    border-radius: 8px;\n}\n\n.message {\n    margin-bottom: 15px;\n    display: flex;\n}\n\n.message.user {\n    justify-content: flex-end;\n}\n\n.message.assistant {\n    justify-content: flex-start;\n}\n\n.message .content {\n    display: inline-block;\n    padding: 12px 15px;\n    border-radius: 18px;\n    max-width: 80%;\n    word-wrap: break-word;\n    font-size: 16px;\n    line-height: 1.4;\n}\n\n.message.user .content {\n    background-color: #0B93F6;\n    color: white;\n    border-bottom-right-radius: 0;\n}\n\n.message.user .content p {\n    margin: 0;\n}\n\n.message.assistant .content {\n    background-color: #E5E5EA;\n    color: black;\n    border-bottom-left-radius: 0;\n}\n\n.message.assistant .content p {\n    margin: 0;\n}\n\n.message .content p {\n    white-space: pre-wrap;\n}\n\n.input-area {\n    height: 9.5vh;\n    display: flex;\n    padding: 6px;\n    background-color: #f0f2f5;\n    border-top: 1px solid #ccc;\n}\n\n#user-input {\n    height: 7.5vh;\n    flex-grow: 1;\n    padding-top: 8px;\n    padding-left: 8px;\n    padding-right: 8px;\n    border: 1px solid #ccc;\n    border-radius: 18px;\n    font-size: 16px;\n    resize: none;\n}\n\n#send-button {\n    margin-left: 10px;\n    padding: 10px 20px;\n    background-color: #42b72a;\n    border: none;\n    border-radius: 18px;\n    color: white;\n    font-size: 18px;\n    cursor: pointer;\n}\n\n#send-button:hover {\n    background-color: #36a420;\n}\n\n/* Stili per il codice evidenziato */\n.content pre {\n    position: relative;\n    background-color: #1e1e1e; /* Tonalit\u00e0 leggermente pi\u00f9 chiara del nero puro */\n    color: #e4e6eb;\n    padding: 10px;\n    border-radius: 8px;\n    overflow-x: auto;\n    margin: 10px 0;\n}\n\n/* Rimuovi lo sfondo predefinito del codice */\n.content pre code {\n    background: none;\n    padding: 0;\n}\n\n/* Stili per i numeri di riga */\n.hljs-ln-numbers {\n    text-align: right;\n    color: #888;\n    user-select: none; /* Impedisce la selezione */\n    pointer-events: none; /* Impedisce l'interazione */\n}\n\ntd.hljs-ln-line.hljs-ln-code{\n    padding-left: 10px;\n}\n/* Pulsante di copia */\n.copy-button {\n    position: absolute;\n    top: 8px;\n    right: 8px;\n    background-color: #438545;\n    border: none;\n    color: white;\n    padding: 4px 8px;\n    font-size: 12px;\n    cursor: pointer;\n    border-radius: 4px;\n}\n\n.copy-button:hover {\n    background-color: #45a049;\n}\n\n/* Aggiungere uno stile per gli scrollbar personalizzati (opzionale) */\n::-webkit-scrollbar {\n    width: 8px;\n}\n\n::-webkit-scrollbar-track {\n    background: #f0f2f5;\n}\n\n::-webkit-scrollbar-thumb {\n    background-color: #ccc;\n    border-radius: 4px;\n}\n\n::-webkit-scrollbar-thumb:hover {\n    background-color: #aaa;\n}\n\n\npre ::-webkit-scrollbar {\n    height: 5px;\n}\n\n.conversation-item {\n    position: relative;\n    padding-right: 25px; /* Spazio per il pulsante 'x' */\n}\n\n.conversation-item .delete-button {\n    position: absolute;\n    right: 5px;\n    top: 50%;\n    transform: translateY(-50%);\n    background: none;\n    border: none;\n    color: #e4e6eb;\n    font-size: 16px;\n    cursor: pointer;\n    opacity: 0.7;\n}\n\n.conversation-item .delete-button:hover {\n    opacity: 1;\n}\n\n/* Evidenziazione della conversazione selezionata */\n.conversation-item.active {\n    background-color: #3A3B3C;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n.loading-indicator {\n    text-align: center;\n    padding: 10px;\n    color: #888;\n}\n\n.loading-indicator span {\n    font-style: italic;\n}\n\n/* Animazione di caricamento */\n.loading-indicator::after {\n    content: '';\n    display: inline-block;\n    margin-left: 5px;\n    width: 10px;\n    height: 10px;\n    border: 2px solid #888;\n    border-radius: 50%;\n    border-top-color: transparent;\n    animation: spin 1s linear infinite;\n}\n\n@keyframes spin {\n    to {\n        transform: rotate(360deg);\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n@media screen and (max-width: 768px) {\n    .chat-container {\n        flex-direction: column;\n    }\n\n    #conversation-list {\n        width: 100%;\n        margin-top: 0;\n        padding: 10px;\n    }\n\n    #chat-section {\n        width: 100%;\n        margin-top: 0;\n        padding-left: 10px;\n        padding-right: 10px;\n    }\n\n    .input-area {\n        height: auto;\n        flex-direction: column;\n    }\n\n    #user-input {\n        width: 100%;\n        height: auto;\n        min-height: 50px;\n        margin-bottom: 10px;\n    }\n\n    #send-button {\n        width: 100%;\n        padding: 12px;\n    }\n\n    .message .content {\n        max-width: 100%;\n    }\n}\n\n/* Media query per schermi con larghezza massima di 480px (smartphone) */\n@media screen and (max-width: 480px) {\n    header h1 {\n        font-size: 18px;\n    }\n\n    #send-button {\n        font-size: 16px;\n        padding: 10px;\n    }\n\n    .message .content {\n        font-size: 14px;\n    }\n\n    #new-conversation {\n        font-size: 14px;\n        padding: 8px;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n.highlighted-text {\n    font-weight: bold;\n    font-size: 1.1em; /* Aumenta la dimensione del testo del 10% */\n}\n\n\n\n\n.separator {\n    height: 1px;\n    background-color: #ccc;\n    margin: 10px 0;\n}\n\n\n\n\n.message-title {\n    margin: 10px 0;\n    font-weight: bold;\n    font-style: italic;\n}\n\n/* Titolo di livello 3 (###) - il pi\u00f9 PICCOLO */\n.title-level-3 {\n    font-size: 1.18em; /* Aumenta la dimensione del 40% */\n}\n\n/* Titolo di livello 2 (##) */\n.title-level-2 {\n    font-size: 1.28em; /* Aumenta la dimensione del 30% */\n}\n\n/* Titolo di livello 1 (#) */\n.title-level-1 {\n    font-size: 1.38em; /* Aumenta la dimensione del 20% */\n}\n\n\n\n\n/* Stile per il testo in corsivo */\n.content em {\n    font-style: italic;\n}\n\n\n.inline-code {\n    font-family: monospace;\n    background-color: #f0f0f0;\n    padding: 2px 4px;\n    border-radius: 4px;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n.model-selector {\n    position: absolute;\n    top: 10px;\n    right: 20px;\n    display: flex;\n    align-items: center;\n}\n\n.model-selector label {\n    color: white;\n    margin-right: 5px;\n    font-size: 14px;\n}\n\n.model-selector select {\n    padding: 4px 8px;\n    border: none;\n    border-radius: 4px;\n    font-size: 14px;\n}"
        }
    ]
}