{
    "type": "directory",
    "name": ".",
    "children": [
        {
            "type": "directory",
            "name": ".git",
            "children": []
        },
        {
            "type": "directory",
            "name": "api",
            "children": [
                {
                    "type": "file",
                    "name": "chat.js",
                    "content": "const { Configuration, OpenAIApi } = require('openai');\nconst { Client } = require('pg');\n\n// Inizializza la configurazione di OpenAI\nconst configuration = new Configuration({\n  apiKey: process.env.OPENAI_API_KEY, // Assicurati che la variabile d'ambiente sia impostata\n});\n\nconst openai = new OpenAIApi(configuration);\n\n// Configurazione del client PostgreSQL\nconst client = new Client({\n  connectionString: process.env.DATABASE_URL \n                    || 'postgres://default:xxx...verceldb?sslmode=require'\n});\n\nclient.connect();\n\n/**\n * Helper per convertire array di blocchi (testo / immagini) in una stringa\n * per la chiamata a OpenAI.\n */\nfunction blocksToText(blocks) {\n  return blocks.map(block => {\n    if (block.type === 'text') {\n      return block.text;\n    }\n    if (block.type === 'image_url') {\n      return '[immagine]';\n    }\n    return '';\n  }).join(' ');\n}\n\nmodule.exports = async (req, res) => {\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Metodo non consentito' });\n  }\n\n  const { conversation_id, message, model } = req.body;\n  let conversationId = conversation_id;\n\n  // Se conversationId non \u00e8 fornito, crea una nuova conversazione\n  if (!conversationId) {\n    try {\n      const result = await client.query(\n        'INSERT INTO conversations (conversation_name) VALUES ($1) RETURNING conversation_id',\n        ['Nuova Conversazione']\n      );\n      conversationId = result.rows[0].conversation_id;\n    } catch (error) {\n      console.error('Errore nella creazione della nuova conversazione:', error);\n      return res.status(500).json({ error: 'Errore interno del server' });\n    }\n  }\n\n  // Recupera la cronologia dei messaggi per la conversazione corrente\n  let messages = [];\n  try {\n    messages = await getMessagesForOpenAI(conversationId);\n  } catch (error) {\n    console.error('Errore nel recupero dei messaggi:', error);\n    return res.status(500).json({ error: 'Errore interno del server' });\n  }\n\n  // Prepara il testo da inviare a OpenAI\n  // Se message \u00e8 un array di blocchi, converti in stringa\n  let userTextForOpenAI = '';\n  if (Array.isArray(message)) {\n    userTextForOpenAI = blocksToText(message);\n  } else {\n    // Altrimenti, \u00e8 una stringa\n    userTextForOpenAI = message || '';\n  }\n\n  // Aggiungi il messaggio dell'utente all'array che andr\u00e0 a OpenAI\n  messages.push({ role: 'user', content: userTextForOpenAI });\n\n  // Salva il messaggio dell'utente nel DB (testo + JSON se presente)\n  try {\n    await saveMessage(conversationId, 'user', message);\n  } catch (error) {\n    console.error('Errore nell\\'inserimento del messaggio utente:', error);\n    return res.status(500).json({ error: 'Errore interno del server durante l\\'inserimento' });\n  }\n\n  // Genera la risposta utilizzando l'API di OpenAI\n  const usedModel = model || 'o1-mini';\n  try {\n    const completion = await openai.createChatCompletion({\n      model: usedModel,\n      messages: messages,\n    });\n\n    const assistantMessage = completion.data.choices[0].message.content;\n\n    // Salva il messaggio dell'assistente nel DB\n    try {\n      await saveMessage(conversationId, 'assistant', assistantMessage);\n    } catch (error) {\n      console.error('Errore nell\\'inserimento del messaggio assistant:', error);\n      return res.status(500).json({ error: 'Errore nel salvataggio della risposta assistant' });\n    }\n\n    // Rispondi al front-end con l'ID della conversazione e la risposta\n    return res.status(200).json({ conversation_id: conversationId, response: assistantMessage });\n  } catch (error) {\n    console.error(\n      'Errore nella chiamata all\\'API di OpenAI:',\n      error.response ? error.response.data : error.message\n    );\n    return res.status(500).json({ error: 'Errore interno del server' });\n  }\n};\n\n/**\n * Recupera i messaggi da DB e li trasforma nel formato {role, content} \n * che serve a OpenAI. Se hai introdotto la colonna content_json,\n * la useremo per generare testo quando presente.\n */\nasync function getMessagesForOpenAI(conversationId) {\n  const queryResult = await client.query(\n    `SELECT role, content, content_json\n       FROM messages\n      WHERE conversation_id = $1\n      ORDER BY created_at ASC`,\n    [conversationId]\n  );\n\n  // Converte ciascun record in { role, content: '...' } per OpenAI\n  return queryResult.rows.map(row => {\n    if (row.content_json) {\n      // Se c'\u00e8 un JSON di blocchi, lo parsiamo e uniamo in testo\n      const blocks = JSON.parse(row.content_json);\n      const text = blocksToText(blocks);\n      return { role: row.role, content: text };\n    }\n    // Altrimenti, usiamo content\n    return { role: row.role, content: row.content || '' };\n  });\n}\n\n/**\n * Salva un messaggio nel DB, gestendo la distinzione tra stringa e array di blocchi.\n * Se message \u00e8 un array => content_json, se string => content, in modo da\n * non violare i vincoli NOT NULL e avere la struttura JSON disponibile.\n */\nasync function saveMessage(conversationId, role, rawMessage) {\n  // Evitiamo errori di not-null su content\n  let textContent = '';\n  let contentJsonString = null;\n\n  if (Array.isArray(rawMessage)) {\n    contentJsonString = JSON.stringify(rawMessage); // Salviamo l'array in JSON\n  } else {\n    textContent = rawMessage || ''; // Se \u00e8 stringa, la mettiamo in content\n  }\n\n  await client.query(\n    `INSERT INTO messages (conversation_id, role, content, content_json)\n     VALUES ($1, $2, $3, $4)`,\n    [conversationId, role, textContent, contentJsonString]\n  );\n}"
                },
                {
                    "type": "file",
                    "name": "conversations.js",
                    "content": "const { Client } = require('pg');\n\n// Configurazione del client PostgreSQL\nconst client = new Client({\n    connectionString: process.env.DATABASE_URL || 'postgres://default:8nCx5XIZurDd@ep-soft-tooth-a45f5lao-pooler.us-east-1.aws.neon.tech:5432/verceldb?sslmode=require'\n});\n\nclient.connect();\n\nmodule.exports = async (req, res) => {\n    if (req.method === 'GET') {\n        // Se viene passato un ID, ritorna la conversazione specifica\n        if (req.query.id) {\n            const conversationId = req.query.id;\n            const messagesRes = await client.query(\n                'SELECT role, content FROM messages WHERE conversation_id = $1 ORDER BY created_at ASC',\n                [conversationId]\n            );\n            res.status(200).json({ messages: messagesRes.rows });\n        } else {\n            // Altrimenti, ritorna tutte le conversazioni\n            const conversationsRes = await client.query(\n                'SELECT conversation_id, conversation_name FROM conversations ORDER BY created_at DESC'\n            );\n            res.status(200).json(conversationsRes.rows);\n        }\n    } else if (req.method === 'POST') {\n        const { conversation_name } = req.body;\n        const insertRes = await client.query(\n            'INSERT INTO conversations (conversation_name) VALUES ($1) RETURNING conversation_id',\n            [conversation_name]\n        );\n        const conversationId = insertRes.rows[0].conversation_id;\n        res.status(201).json({ conversation_id: conversationId });\n    } else if (req.method === 'DELETE') {\n        const conversationId = req.query.id;\n        if (!conversationId) {\n            res.status(400).json({ error: 'ID conversazione mancante' });\n            return;\n        }\n\n        try {\n            // Elimina i messaggi associati alla conversazione\n            await client.query('DELETE FROM messages WHERE conversation_id = $1', [conversationId]);\n\n            // Elimina la conversazione\n            await client.query('DELETE FROM conversations WHERE conversation_id = $1', [conversationId]);\n\n            res.status(200).json({ message: 'Conversazione eliminata con successo' });\n        } catch (error) {\n            console.error('Errore nell\\'eliminazione della conversazione:', error);\n            res.status(500).json({ error: 'Errore interno del server' });\n        }\n    } else {\n        res.status(405).json({ error: 'Metodo non consentito' });\n    }\n};"
                },
                {
                    "type": "file",
                    "name": "uploadImage.js",
                    "content": "const cloudinary = require('cloudinary');\nconst multiparty = require('multiparty');\n\nmodule.exports = async (req, res) => {\n  if (req.method === 'POST') {\n    const form = new multiparty.Form();\n\n    form.parse(req, async (err, fields, files) => {\n      if (err) {\n        return res.status(500).json({ error: 'Errore parse form-data' });\n      }\n\n      try {\n        /*\n         Se stai inviando il base64 come fields.base64 (stringa base64):\n           es: formData.append('base64', laTuaStringBase64);\n         \n         Altrimenti se stai ancora inviando un file binario,\n         gestisci files.fileInputName[0].path come prima.\n        */\n        const base64Data = fields.base64?.[0]; \n        if (!base64Data) {\n          return res.status(400).json({ error: 'Manca il campo base64' });\n        }\n\n        // Carica su Cloudinary (puoi aggiungere \"data:image/jpeg;base64,\" prima di base64Data)\n        const result = await cloudinary.uploader.upload(\n          `data:image/jpeg;base64,${base64Data}`,\n          { folder: 'o1-private-imgs' }\n        );\n        \n        // Restituisco l\u2019URL ottenuto\n        return res.status(200).json({ url: result.url });\n\n      } catch (errUpload) {\n        console.error('Errore upload su Cloudinary:', errUpload);\n        return res.status(500).json({ error: 'Errore nell\\'upload a Cloudinary' });\n      }\n    });\n  } else {\n    res.status(405).json({ error: 'Metodo non consentito' });\n  }\n};"
                }
            ]
        },
        {
            "type": "file",
            "name": "backup.text"
        },
        {
            "type": "file",
            "name": "dir_map.json"
        },
        {
            "type": "file",
            "name": "index.html",
            "content": "<!DOCTYPE html>\n<html lang=\"it\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Chatbot AI</title>\n    <meta content=\"width=device-width, initial-scale=1.0\" name=\"viewport\"/>\n    <link rel=\"stylesheet\" href=\"styles.css\">\n    <!-- Includi Highlight.js per la sintassi evidenziata -->\n    <link rel=\"stylesheet\" href=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github-dark.min.css\">\n</head>\n<body>\n    <div class=\"chat-container\">\n        <header>\n            <h1>o1-preview | <span>assistenti custom</span></h1>\n            <!-- Aggiungi il selettore del modello -->\n            <div class=\"model-selector\">\n                <label for=\"model-select\">Modello:</label>\n                <select id=\"model-select\">\n                    <option value=\"o1-2024-12-17\">o1</option>\n                    <option value=\"o1-mini\">o1-mini</option>\n                    <option value=\"o1-preview\">o1-preview</option>\n                    <option value=\"gpt-3.5-turbo\">gpt-4o</option>\n                    <!-- Aggiungi altri modelli se necessario -->\n                </select>\n                <div class=\"formatting-toggle\">\n                    <input type=\"checkbox\" id=\"disable-formatting\" />\n                    <label for=\"disable-formatting\">Disattiva formattazione</label>\n                </div>\n            </div>\n            <!-- Aggiungi questo blocco dove preferisci, ad esempio di fianco al selettore del modello -->\n            \n  \n        </header>\n        <div id=\"conversation-list\">\n            <h2>Conversazioni</h2>\n            <ul id=\"conversations\"></ul>\n            <div id=\"button-wrapper\">\n                <button id=\"new-conversation\">+ Nuova Conversazione</button>\n            </div>\n        </div>\n        <div id=\"chat-section\">\n            <div id=\"chat-window\"></div>\n            <div class=\"input-area\">\n                <textarea id=\"user-input\" placeholder=\"Scrivi un messaggio...\"></textarea>\n                <!-- Pulsante per allegare immagini -->\n                <input \n                id=\"upload-input\" \n                type=\"file\" \n                accept=\"image/*\" \n                multiple \n                style=\"display: none;\" \n                />\n                <button id=\"upload-button\" style=\"margin-right:8px;\">Allega Immagine</button>\n\n                <!-- Pulsante di invio -->\n                <button id=\"send-button\">Invia</button>\n            </div>\n        </div>\n    </div>\n\n        <!-- Modal per Anteprima Conversazione -->\n    <div id=\"preview-modal\" class=\"modal\">\n        <div class=\"modal-content\">\n        <span class=\"close-button\">&times;</span>\n        <h2>Anteprima Conversazione</h2>\n        <div id=\"preview-messages\"></div>\n        </div>\n    </div>\n\n    <!-- Include le librerie di Highlight.js -->\n    <script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js\"></script>\n    <!-- Includi i linguaggi che desideri supportare -->\n    <script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js\"></script>\n    <script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js\"></script>\n    <script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/css.min.js\"></script>\n    <script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/php.min.js\"></script>\n    <script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/json.min.js\"></script>\n    <script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/java.min.js\"></script>\n    <script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/csharp.min.js\"></script>\n    <script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/ruby.min.js\"></script>\n    <script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/sql.min.js\"></script>\n\n    \n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.1.6/purify.min.js\" integrity=\"sha512-jB0TkTBeQC9ZSkBqDhdmfTv1qdfbWpGE72yJ/01Srq6hEzZIz2xkz1e57p9ai7IeHMwEG7HpzG6NdptChif5Pg==\" crossorigin=\"anonymous\" referrerpolicy=\"no-referrer\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js\"></script>\n    <!-- Il tuo script principale -->\n    <script type=\"module\" src=\"script.js\"></script>\n</html>"
        },
        {
            "type": "file",
            "name": "map.py"
        },
        {
            "type": "file",
            "name": "package-lock.json"
        },
        {
            "type": "file",
            "name": "package.json"
        },
        {
            "type": "file",
            "name": "script.js",
            "content": "document.addEventListener('DOMContentLoaded', () => {\n    // Riferimenti a vari elementi del DOM\n    const chatWindow = document.getElementById('chat-window');\n    const sendButton = document.getElementById('send-button');\n    const userInput = document.getElementById('user-input');\n    const conversationsList = document.getElementById('conversations');\n    const newConversationButton = document.getElementById('new-conversation');\n    const modelSelect = document.getElementById('model-select');\n\n    let pendingImages = []; // Array con i base64 delle immagini in attesa di invio\n\n    const uploadButton = document.getElementById('upload-button');\n    const uploadInput   = document.getElementById('upload-input');\n\n    // Quando clicco su \u201cAllega Immagine\u201d apro il file-selector\n    uploadButton.addEventListener('click', () => {\n        uploadInput.click();\n    });\n\n    // Leggo i file selezionati e li converto in base64\n    uploadInput.addEventListener('change', async (event) => {\n        const files = event.target.files;\n        if (!files || files.length === 0) return;\n      \n        for (let file of files) {\n          try {\n            const base64Data = await convertFileToBase64(file);\n            \n            // Invio base64 allo /api/uploadImage per ottenere un URL Cloudinary:\n            const cloudUrl = await uploadBase64ToCloudinary(base64Data);\n            \n            // Cos\u00ec manteniamo un oggetto con base64 e url:\n            pendingImages.push({\n              base64: base64Data,\n              url: cloudUrl\n            });\n      \n            // Mostro subito l\u2019immagine usando l\u2019url reale (Cloudinary), \n            // cos\u00ec non appendiamo un enorme base64 nell\u2019 <img>\n            displayImageMessage('user', cloudUrl);\n      \n          } catch (err) {\n            console.error('Errore durante la generazione/upload base64:', err);\n          }\n        }\n        uploadInput.value = '';\n      });\n\n      async function uploadBase64ToCloudinary(base64String) {\n        // Inviamo con multiparty in un field \u201cbase64\u201d\n        const formData = new FormData();\n        formData.append('base64', base64String);\n      \n        const response = await fetch('/api/uploadImage', {\n          method: 'POST',\n          body: formData\n        });\n        const data = await response.json();\n        if (!response.ok) {\n          throw new Error(data.error || 'Errore nell\\'upload');\n        }\n        return data.url; // L\u2019URL di Cloudinary\n      }\n\n\n    function convertFileToBase64(file) {\n        return new Promise((resolve, reject) => {\n            const reader = new FileReader();\n            reader.onload = () => {\n                resolve(reader.result.replace(/^data:image\\/[a-zA-Z]+;base64,/, ''));\n            };\n            reader.onerror = (error) => reject(error);\n            reader.readAsDataURL(file);\n        });\n    }\n\n\n\n    function displayTempImageMessage(base64Image) {\n        // Visualizza un \u201cbox messaggio\u201d con l\u2019anteprima dell\u2019immagine\n        const messageDiv = document.createElement('div');\n        messageDiv.classList.add('message', 'user');  // o 'assistant' se preferisci\n        const contentDiv = document.createElement('div');\n        contentDiv.classList.add('content');\n    \n        // Crea un <img> con la base64\n        const imageElem = document.createElement('img');\n        imageElem.src = `data:image/jpeg;base64,${base64Image}`;\n        imageElem.style.maxWidth = '200px';\n        imageElem.style.borderRadius = '8px';\n    \n        contentDiv.appendChild(imageElem);\n        messageDiv.appendChild(contentDiv);\n        chatWindow.appendChild(messageDiv);\n    \n        messageDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });\n    }\n    // --- Gestione stato della formattazione ---\n    // Di default la formattazione \u00e8 ATTIVA (checkbox non spuntato).\n    let disableFormatting = false;\n    const disableFormattingCheckbox = document.getElementById('disable-formatting');\n    if (disableFormattingCheckbox) {\n      disableFormattingCheckbox.addEventListener('change', (e) => {\n        disableFormatting = e.target.checked;\n        // Quando l'utente cambia lo stato della formattazione,\n        // ri-renderizziamo i messaggi della conversazione corrente (se presente).\n        renderMessages();\n      });\n    }\n\n    // Id della conversazione attuale\n    let currentConversationId = null;\n\n    // Array che contiene i messaggi dell'attuale conversazione\n    let currentMessages = [];\n\n    // Modello selezionato\n    let selectedModel = 'o1-mini'; \n    if (modelSelect) {\n      selectedModel = modelSelect.value;\n      \n    }\n    modelSelect.addEventListener('change', () => {\n        selectedModel = modelSelect.value;\n    });\n\n\n\n\n\n    async function uploadFile(file) {\n        const formData = new FormData();\n        formData.append('fileInputName', file);\n      \n        const response = await fetch('/api/uploadImage', {\n          method: 'POST',\n          body: formData\n        });\n        const data = await response.json();\n        return data.url; // L\u2019URL dell\u2019immagine su Cloudinary\n      }\n\n    /**\n     * Carica la lista di conversazioni esistenti dal server\n     * e popola il menu laterale.\n     */\n    function loadConversations() {\n        fetch('/api/conversations')\n            .then(response => response.json())\n            .then(data => {\n                conversationsList.innerHTML = '';\n                data.forEach(conv => {\n                    const li = document.createElement('li');\n                    li.textContent = conv.conversation_name;\n                    li.dataset.id = conv.conversation_id;\n                    li.classList.add('conversation-item');\n\n                    // Listener per selezionare la conversazione\n                    li.addEventListener('click', () => {\n                        currentConversationId = conv.conversation_id;\n                        loadConversation(conv.conversation_id);\n                        updateActiveConversation(conv.conversation_id);\n                    });\n\n                    // Pulsante di eliminazione\n                    const deleteButton = document.createElement('button');\n                    deleteButton.textContent = '\u00d7'; // Simbolo 'x'\n                    deleteButton.classList.add('delete-button');\n                    // Preveniamo la propagazione per non scatenare il click sulla li\n                    deleteButton.addEventListener('click', (e) => {\n                        e.stopPropagation();\n                        deleteConversation(conv.conversation_id, conv.conversation_name);\n                    });\n\n                    // Pulsante di anteprima\n                    const previewButton = document.createElement('button');\n                    previewButton.innerHTML = '\ud83d\udd0d'; // Icona stile \u201clente\u201d\n                    previewButton.classList.add('preview-button');\n                    previewButton.addEventListener('click', (e) => {\n                        e.stopPropagation();\n                        showPreview(conv.conversation_id);\n                    });\n\n                    // Aggiunta pulsanti alla li\n                    li.appendChild(deleteButton);\n                    li.appendChild(previewButton);\n                    conversationsList.appendChild(li);\n                });\n\n                // Aggiorna l'evidenziazione della conversazione attiva\n                updateActiveConversation(currentConversationId);\n            })\n            .catch(error => console.error('Errore nel caricamento delle conversazioni:', error));\n    }\n\n    /**\n     * Aggiorna la classe 'active' sulla conversazione selezionata\n     */\n    function updateActiveConversation(conversationId) {\n        const conversationItems = document.querySelectorAll('.conversation-item');\n        conversationItems.forEach(item => {\n            if (parseInt(item.dataset.id) === conversationId) {\n                item.classList.add('active');\n            } else {\n                item.classList.remove('active');\n            }\n        });\n    }\n\n    /**\n     * Elimina la conversazione dal database e aggiorna la lista\n     */\n    function deleteConversation(conversationId, conversationName) {\n        const confirmDelete = confirm(`Sei sicuro di voler eliminare la conversazione \"${conversationName}\"?`);\n        if (confirmDelete) {\n            fetch(`/api/conversations?id=${conversationId}`, {\n                method: 'DELETE',\n            })\n                .then(response => {\n                    if (response.ok) {\n                        // Se la conversazione eliminata era quella attiva, resettiamo\n                        if (currentConversationId === conversationId) {\n                            currentConversationId = null;\n                            currentMessages = [];\n                            chatWindow.innerHTML = '';\n                        }\n                        loadConversations();\n                    } else {\n                        console.error('Errore nell\\'eliminazione della conversazione.');\n                    }\n                })\n                .catch(error => console.error('Errore nella comunicazione con l\\'API:', error));\n        }\n    }\n\n    /**\n     * Carica dal server i messaggi di una conversazione specifica\n     */\n    function loadConversation(conversationId) {\n        fetch(`/api/conversations?id=${conversationId}`)\n            .then(response => response.json())\n            .then(data => {\n                // Salviamo i messaggi in currentMessages\n                currentMessages = data.messages || [];\n                renderMessages();\n            })\n            .catch(error => console.error('Errore nel caricamento della conversazione:', error));\n    }\n\n    function displayTextMessage(role, text) {\n        const messageDiv = document.createElement('div');\n        messageDiv.classList.add('message', role);\n    \n        const contentDiv = document.createElement('div');\n        contentDiv.classList.add('content');\n        // Se vuoi formattazione/disattivarla, decidi tu\n        contentDiv.textContent = text;\n    \n        messageDiv.appendChild(contentDiv);\n        chatWindow.appendChild(messageDiv);\n        messageDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });\n      }\n\n      function displayImageMessage(role, imageUrl) {\n        const messageDiv = document.createElement('div');\n        messageDiv.classList.add('message', role);\n    \n        const contentDiv = document.createElement('div');\n        contentDiv.classList.add('content');\n    \n        const imgElem = document.createElement('img');\n        imgElem.src = imageUrl;\n        imgElem.style.maxWidth = '200px';\n        imgElem.style.borderRadius = '8px';\n    \n        contentDiv.appendChild(imgElem);\n        messageDiv.appendChild(contentDiv);\n        chatWindow.appendChild(messageDiv);\n        messageDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });\n      }\n\n    /**\n     * renderMessages()\n     * Svuota il chatWindow e visualizza i messaggi in currentMessages\n     * rispettando lo stato di disableFormatting.\n     */\n    function renderMessages() {\n        chatWindow.innerHTML = '';\n        currentMessages.forEach(msg => {\n          // msg avr\u00e0 shape: { role: 'user'|'assistant', content: string, content_json: [{...}]|null }\n          if (msg.content_json && Array.isArray(msg.content_json)) {\n            // Cicla i blocchi\n            msg.content_json.forEach(block => {\n              if (block.type === 'text') {\n                displayTextMessage(msg.role, block.text);\n              } else if (block.type === 'image_url') {\n                displayImageMessage(msg.role, block.image_url.url);\n              }\n            });\n          } else {\n            // Altrimenti, \u00e8 un semplice testo\n            displayTextMessage(msg.role, msg.content);\n          }\n        });\n      }\n\n\n\n    /**\n     * Visualizza un singolo messaggio nel chatWindow.\n     * Se disableFormatting \u00e8 attivo e il ruolo \u00e8 'assistant',\n     * mostriamo il testo raw (textContent) senza parse di blocchi di codice, etc.\n     */\n    function displayMessage(role, content, highlight = false) {\n        const messageDiv = document.createElement('div');\n        messageDiv.classList.add('message', role);\n        if (highlight) {\n            messageDiv.classList.add('highlighted-message');\n        }\n\n        const contentDiv = document.createElement('div');\n        contentDiv.classList.add('content');\n\n        if (role === 'assistant') {\n            // Se formattazione disattivata => mostra testo raw\n            if (disableFormatting) {\n                const textParagraph = document.createElement('p');\n                textParagraph.textContent = content.trim();\n                contentDiv.appendChild(textParagraph);\n            } \n            else {\n                // Formattazione classica (code blocks, parseMessageContent, ecc.)\n                const messageParts = parseMessageContent(content);\n                messageParts.forEach(part => {\n                    if (part.type === 'code') {\n                        const pre = document.createElement('pre');\n                        const code = document.createElement('code');\n                        code.classList.add(part.language || 'plaintext');\n                        code.textContent = part.code.trim();\n                        pre.appendChild(code);\n\n                        // Pulsante di copia\n                        const copyButton = document.createElement('button');\n                        copyButton.textContent = 'Copia';\n                        copyButton.classList.add('copy-button');\n                        copyButton.addEventListener('click', () => {\n                            const codeText = part.code.trim();\n                            navigator.clipboard.writeText(codeText).then(() => {\n                                copyButton.textContent = 'Copiato!';\n                                setTimeout(() => {\n                                    copyButton.textContent = 'Copia';\n                                }, 2000);\n                            }).catch(err => {\n                                console.error('Errore nel copiare il codice:', err);\n                            });\n                        });\n                        pre.appendChild(copyButton);\n                        contentDiv.appendChild(pre);\n\n                        // Evidenzia sintassi\n                        hljs.highlightElement(code);\n                        hljs.lineNumbersBlock(code);\n                    }\n                    else if (part.type === 'separator') {\n                        const separatorDiv = document.createElement('div');\n                        separatorDiv.classList.add('separator');\n                        contentDiv.appendChild(separatorDiv);\n                    }\n                    else if (part.type === 'title') {\n                        const titleElement = document.createElement('div');\n                        titleElement.classList.add('message-title', `title-level-${part.level}`);\n                        titleElement.innerHTML = DOMPurify.sanitize(formatBoldText(part.text));\n                        contentDiv.appendChild(titleElement);\n                    }\n                    else {\n                        // Testo normale\n                        const textParagraph = document.createElement('p');\n                        textParagraph.innerHTML = DOMPurify.sanitize(formatBoldText(part.text.trim()));\n                        contentDiv.appendChild(textParagraph);\n                    }\n                });\n            }\n        } \n        else {\n            // Messaggi dell\u2019utente (o altri ruoli) => testo raw\n            const textParagraph = document.createElement('p');\n            textParagraph.textContent = content.trim();\n            contentDiv.appendChild(textParagraph);\n        }\n\n        messageDiv.appendChild(contentDiv);\n        chatWindow.appendChild(messageDiv);\n\n        // Scrolla la chat per mostrare il nuovo messaggio\n        messageDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });\n    }\n\n    /**\n     * Funzione per formattare testo in grassetto e corsivo (solo assistant),\n     * usata da parseMessageContent durante la formattazione\n     */\n    function formatBoldText(text) {\n        const boldRegex = /\\*\\*(.*?)\\*\\*/g;\n        const formattedText = text.replace(boldRegex, '<strong class=\"highlighted-text\">$1</strong>');\n        return formatItalicText(formattedText);\n    }\n    function formatItalicText(text) {\n        const italicRegex = /`([^`]+)`/g;\n        return text.replace(italicRegex, '<em>$1</em>');\n    }\n\n    /**\n     * parseMessageContent(content)\n     * Suddivide il testo in parti: code block, titoli, separatori, testo normale\n     */\n    function parseMessageContent(content) {\n        const codeRegex = /```(\\w*)\\s*\\n?([\\s\\S]*?)\\n?```/g;\n        const parts = [];\n        let lastIndex = 0;\n        let match;\n\n        // Estrarre i blocchi di codice\n        while ((match = codeRegex.exec(content)) !== null) {\n            if (match.index > lastIndex) {\n                const textBefore = content.substring(lastIndex, match.index);\n                parseTextParts(textBefore, parts);\n            }\n            parts.push({\n                type: 'code',\n                language: match[1] || '',\n                code: match[2]\n            });\n            lastIndex = codeRegex.lastIndex;\n        }\n        // Testo dopo l'ultimo blocco di codice\n        if (lastIndex < content.length) {\n            const textAfter = content.substring(lastIndex);\n            parseTextParts(textAfter, parts);\n        }\n        return parts;\n    }\n\n    /**\n     * parseTextParts(text, parts)\n     * Riconosce titoli e separatori. Aggiorna l\u2019array `parts` con i relativi oggetti.\n     */\n    function parseTextParts(text, parts) {\n        const titleRegex = /^(#{1,3})\\s*(.*)$/gm;\n        let lastIndex = 0;\n        let match;\n\n        while ((match = titleRegex.exec(text)) !== null) {\n            // Testo prima del titolo\n            if (match.index > lastIndex) {\n                const precedingText = text.substring(lastIndex, match.index);\n                parseSeparatorsAndText(precedingText, parts);\n            }\n            const level = match[1].length; // #, ##, o ###\n            const titleText = match[2].trim();\n\n            parts.push({\n                type: 'title',\n                level: level,\n                text: titleText\n            });\n            lastIndex = titleRegex.lastIndex;\n        }\n\n        // Testo dopo l'ultimo titolo\n        if (lastIndex < text.length) {\n            const remainingText = text.substring(lastIndex);\n            parseSeparatorsAndText(remainingText, parts);\n        }\n    }\n\n    /**\n     * parseSeparatorsAndText(text, parts)\n     * Suddivide ulteriormente per separatori (---).\n     */\n    function parseSeparatorsAndText(text, parts) {\n        const separatorRegex = /^---$/gm;\n        let lastIndex = 0;\n        let match;\n\n        while ((match = separatorRegex.exec(text)) !== null) {\n            if (match.index > lastIndex) {\n                parts.push({\n                    type: 'text',\n                    text: text.substring(lastIndex, match.index)\n                });\n            }\n            parts.push({ type: 'separator' });\n            lastIndex = separatorRegex.lastIndex;\n        }\n        if (lastIndex < text.length) {\n            parts.push({\n                type: 'text',\n                text: text.substring(lastIndex)\n            });\n        }\n    }\n\n    // Loading indicator\n    let loadingIndicator = null;\n    function showLoading() {\n        if (!loadingIndicator) {\n            loadingIndicator = document.createElement('div');\n            loadingIndicator.classList.add('loading-indicator');\n            loadingIndicator.innerHTML = `<span>Caricamento...</span>`;\n        }\n        chatWindow.appendChild(loadingIndicator);\n        loadingIndicator.scrollIntoView({ behavior: 'smooth', block: 'start' });\n    }\n    function hideLoading() {\n        if (loadingIndicator) {\n            chatWindow.removeChild(loadingIndicator);\n            loadingIndicator = null;\n        }\n    }\n\n    // Inviare il messaggio\n    sendButton.addEventListener('click', () => {\n        const userInputValue = userInput.value.trim();\n        if (userInputValue === '' && pendingImages.length === 0) return;\n      \n        let content;\n        if (pendingImages.length > 0) {\n          content = [];\n          if (userInputValue !== '') {\n            content.push({ type: 'text', text: userInputValue });\n          }\n      \n          // Ciascun elemento di pendingImages ha { base64, url }, \n          // dove base64 \u00e8 la stringa raw, url \u00e8 Cloudinary\n          for (const imgObj of pendingImages) {\n            content.push({\n              type: 'image_url',\n              // Il \u201cprincipale\u201d rimane base64, come richiesto (\u201cmantieni l\u2019invio in base64\u201d)\n              image_url: {\n                url: `data:image/jpeg;base64,${imgObj.base64}`,\n                detail: 'high'\n              },\n              // Se vuoi memorizzare anche l\u2019URL reale (per uso server/later):\n              cloud_url: imgObj.url \n            });\n          }\n          pendingImages = [];\n        } else {\n          content = userInputValue;\n        }\n      \n        // (Visualizzazione immediata del testo, se desideri)\n        if (userInputValue) {\n          displayTextMessage('user', userInputValue);\n        }\n        userInput.value = '';\n      \n        showLoading();\n      \n        fetch('/api/chat', {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({\n            conversation_id: currentConversationId,\n            message: content,\n            model: selectedModel\n          })\n        })\n        .then(res => res.json())\n        .then(data => {\n          currentConversationId = data.conversation_id;\n          hideLoading();\n          loadConversation(currentConversationId);\n        })\n        .catch(err => {\n          console.error('Errore nella comunicazione con /api/chat:', err);\n          hideLoading();\n        });\n      });\n\n    // Nuova conversazione\n    newConversationButton.addEventListener('click', () => {\n        const conversationName = prompt('Inserisci un nome per la nuova conversazione:');\n        if (conversationName) {\n            fetch('/api/conversations', {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({ conversation_name: conversationName })\n            })\n            .then(response => response.json())\n            .then(data => {\n                currentConversationId = data.conversation_id;\n                currentMessages = [];\n                chatWindow.innerHTML = '';\n                loadConversations();\n            })\n            .catch(error => console.error('Errore nella creazione della conversazione:', error));\n        }\n    });\n\n    // Carica le conversazioni all'avvio\n    loadConversations();\n\n\n    // =========================\n    //  Modal Anteprima \n    // =========================\n    const modal = document.getElementById('preview-modal');\n    const closeButton = modal.querySelector('.close-button');\n\n    closeButton.addEventListener('click', closePreview);\n    window.addEventListener('click', (event) => {\n        if (event.target === modal) {\n            closePreview();\n        }\n    });\n    function closePreview() {\n        modal.style.display = 'none';\n    }\n\n    /**\n     * showPreview(conversationId)\n     * Mostra anteprima rapida della conversazione in un modal\n     */\n    function showPreview(conversationId) {\n        fetch(`/api/conversations?id=${conversationId}`)\n            .then(response => response.json())\n            .then(data => {\n                const previewMessagesDiv = document.getElementById('preview-messages');\n                previewMessagesDiv.innerHTML = ''; \n                const messages = data.messages;\n\n                messages.forEach((msg, index) => {\n                    const messageDiv = document.createElement('div');\n                    messageDiv.classList.add('message', msg.role);\n\n                    const contentDiv = document.createElement('div');\n                    contentDiv.classList.add('content');\n\n                    let text = msg.content;\n                    // Tronca i messaggi lunghi (opzionale)\n                    if (text.length > 200) {\n                        text = text.substring(0, 200) + '...';\n                    }\n                    contentDiv.textContent = text;\n                    messageDiv.appendChild(contentDiv);\n                    previewMessagesDiv.appendChild(messageDiv);\n\n                    // Clic su un messaggio per \u201cnavigare\u201d\n                    messageDiv.addEventListener('click', () => {\n                        navigateToMessage(conversationId, index);\n                        closePreview();\n                    });\n                });\n\n                modal.style.display = 'block';\n            })\n            .catch(error => console.error('Errore nel recupero della conversazione:', error));\n    }\n\n    /**\n     * navigateToMessage(conversationId, messageIndex)\n     * Carica la conversazione, scrolla al messaggio \u201cmessageIndex\u201d\n     * e lo evidenzia momentaneamente.\n     */\n    function navigateToMessage(conversationId, messageIndex) {\n        currentConversationId = conversationId;\n        updateActiveConversation(conversationId);\n\n        fetch(`/api/conversations?id=${conversationId}`)\n            .then(response => response.json())\n            .then(data => {\n                chatWindow.innerHTML = '';\n                currentMessages = data.messages;\n                currentMessages.forEach((msg, idx) => {\n                    displayMessage(msg.role, msg.content, idx === messageIndex);\n                });\n                // Scrolla al messaggio evidenziato\n                const messagesInChat = chatWindow.getElementsByClassName('message');\n                if (messageIndex < messagesInChat.length) {\n                    const targetMessage = messagesInChat[messageIndex];\n                    targetMessage.scrollIntoView({ behavior: 'smooth', block: 'center' });\n                    // Rimuove la classe highlight dopo 2 secondi\n                    setTimeout(() => {\n                        targetMessage.classList.remove('highlighted-message');\n                    }, 2000);\n                }\n            })\n            .catch(error => console.error('Errore nella navigazione alla conversazione:', error));\n    }\n\n});\n"
        },
        {
            "type": "file",
            "name": "styles.css",
            "content": "body {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    background-color: #f0f2f5;\n    margin: 0;\n    padding: 0;\n}\n\n.chat-container {\n    display: flex;\n    height: 100vh;\n}\n\nheader {\n    display: flex;\n    position: fixed;\n    justify-content: center;\n    height: 8vh;\n    width: 100%;\n    border-bottom: 2px solid rgb(0, 0, 0);\n    background: linear-gradient(135deg, rgb(39, 39, 76), rgb(88, 0, 88) 70%);\n    color: white;\n    z-index: 1;\n}\n\nheader h1 {\n    margin-top: auto;\n    margin-bottom: auto;\n}\n\n/* header span{\n    color: #57ff5c;\n} */\n\n#conversation-list {\n    box-sizing: border-box;\n    width: 20%;\n    background-color: #242526;\n    color: #e4e6eb;\n    overflow-y: auto;\n    overflow-x: hidden;\n    padding: 20px 20px 20px; /* Aggiustamento padding per spazio sotto l'header */\n    margin-top: 8vh;\n    padding-bottom: 80px;\n}\n\n\n#conversation-list h2 {\n    margin-top: 0;\n    color: #e4e6eb;\n}\n\n#conversation-list ul {\n    list-style-type: none;\n    padding: 0;\n    margin-top: 20px;\n}\n\n#conversation-list li {\n    padding: 10px;\n    cursor: pointer;\n    border-bottom: 1px solid #3A3B3C;\n}\n\n#conversation-list li:hover, #conversation-list li.active {\n    background-color: #3A3B3C;\n}\n#button-wrapper {\n    position: fixed;\n    left: 0;\n    bottom: 0;\n    width: 20%;\n    padding: 20px;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n\n#new-conversation {\n    width: 100%;\n    padding: 12px 20px;\n    background: linear-gradient(135deg, #003e03, #81C784);\n    border: none;\n    color: white;\n    font-size: 16px;\n    font-weight: bold;\n    text-transform: uppercase;\n    cursor: pointer;\n    border-radius: 10px;\n    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.06);\n    transition: transform 0.2s ease, box-shadow 0.2s ease;\n}\n\n#new-conversation:hover {\n    transform: translateY(-4px);\n    box-shadow: 0 8px 12px rgba(0, 0, 0, 0.1), 0 3px 6px rgba(0, 0, 0, 0.08);\n}\n\n#new-conversation:active {\n    transform: translateY(0);\n    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.06);\n}\n\n\n#chat-section {\n    width: 80%;\n    display: flex;\n    flex-direction: column;\n    padding-top: 15px; /* Aggiustamento padding per spazio sotto l'header */\n    padding-left: 30px; /* Aggiustamento padding per spazio sotto l'header */\n    padding-right: 30px; /* Aggiustamento padding per spazio sotto l'header */\n    border-radius: 10px;\n    margin-top: 8vh;\n    position: relative;\n}\n\n#chat-window {\n    flex-grow: 1;\n    padding: 20px;\n    overflow-y: auto;\n    background-color: #fff;\n    border-radius: 8px;\n}\n\n.message {\n    margin-bottom: 15px;\n    display: flex;\n}\n\n.message.user {\n    justify-content: flex-end;\n}\n\n.message.assistant {\n    justify-content: flex-start;\n}\n\n.message .content {\n    display: inline-block;\n    padding: 12px 15px;\n    border-radius: 18px;\n    max-width: 80%;\n    word-wrap: break-word;\n    font-size: 16px;\n    line-height: 1.4;\n}\n\n.message.user .content {\n    background-color: #0B93F6;\n    color: white;\n    border-bottom-right-radius: 0;\n}\n\n.message.user .content p {\n    margin: 0;\n}\n\n.message.assistant .content {\n    background-color: #E5E5EA;\n    color: black;\n    border-bottom-left-radius: 0;\n}\n\n.message.assistant .content p {\n    margin: 0;\n}\n\n.message .content p {\n    white-space: pre-wrap;\n}\n\n.input-area {\n    height: 9.5vh;\n    display: flex;\n    padding: 6px;\n    background-color: #f0f2f5;\n    border-top: 1px solid #ccc;\n}\n\n#user-input {\n    height: 7.5vh;\n    flex-grow: 1;\n    padding-top: 8px;\n    padding-left: 8px;\n    padding-right: 8px;\n    border: 1px solid #ccc;\n    border-radius: 18px;\n    font-size: 16px;\n    resize: none;\n}\n\n#send-button {\n    margin-left: 10px;\n    padding: 10px 20px;\n    background-color: #42b72a;\n    border: none;\n    border-radius: 18px;\n    color: white;\n    font-size: 18px;\n    cursor: pointer;\n}\n\n#send-button:hover {\n    background-color: #36a420;\n}\n\n/* Stili per il codice evidenziato */\n.content pre {\n    position: relative;\n    background-color: #1e1e1e; /* Tonalit\u00e0 leggermente pi\u00f9 chiara del nero puro */\n    color: #e4e6eb;\n    padding: 10px;\n    border-radius: 8px;\n    overflow-x: auto;\n    margin: 10px 0;\n}\n\n/* Rimuovi lo sfondo predefinito del codice */\n.content pre code {\n    background: none;\n    padding: 0;\n}\n\n/* Stili per i numeri di riga */\n.hljs-ln-numbers {\n    text-align: right;\n    color: #888;\n    user-select: none; /* Impedisce la selezione */\n    pointer-events: none; /* Impedisce l'interazione */\n}\n\ntd.hljs-ln-line.hljs-ln-code{\n    padding-left: 10px;\n}\n/* Pulsante di copia */\n.copy-button {\n    position: absolute;\n    top: 8px;\n    right: 8px;\n    background-color: #438545;\n    border: none;\n    color: white;\n    padding: 4px 8px;\n    font-size: 12px;\n    cursor: pointer;\n    border-radius: 4px;\n}\n\n.copy-button:hover {\n    background-color: #45a049;\n}\n\n/* Aggiungere uno stile per gli scrollbar personalizzati (opzionale) */\n::-webkit-scrollbar {\n    width: 8px;\n}\n\n::-webkit-scrollbar-track {\n    background: #f0f2f5;\n}\n\n::-webkit-scrollbar-thumb {\n    background-color: #ccc;\n    border-radius: 4px;\n}\n\n::-webkit-scrollbar-thumb:hover {\n    background-color: #aaa;\n}\n\n\npre ::-webkit-scrollbar {\n    height: 5px;\n}\n\n.conversation-item {\n    position: relative;\n    padding-right: 25px; /* Spazio per il pulsante 'x' */\n}\n\n.conversation-item .delete-button {\n    position: absolute;\n    right: 5px;\n    top: 50%;\n    transform: translateY(-50%);\n    background: none;\n    border: none;\n    color: #e4e6eb;\n    font-size: 16px;\n    cursor: pointer;\n    opacity: 0.7;\n}\n\n.conversation-item .delete-button:hover {\n    opacity: 1;\n}\n\n/* Evidenziazione della conversazione selezionata */\n.conversation-item.active {\n    background-color: #3A3B3C;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n.loading-indicator {\n    text-align: center;\n    padding: 10px;\n    color: #888;\n}\n\n.loading-indicator span {\n    font-style: italic;\n}\n\n/* Animazione di caricamento */\n.loading-indicator::after {\n    content: '';\n    display: inline-block;\n    margin-left: 5px;\n    width: 10px;\n    height: 10px;\n    border: 2px solid #888;\n    border-radius: 50%;\n    border-top-color: transparent;\n    animation: spin 1s linear infinite;\n}\n\n@keyframes spin {\n    to {\n        transform: rotate(360deg);\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n@media screen and (max-width: 768px) {\n    .chat-container {\n        flex-direction: column;\n    }\n\n    #conversation-list {\n        width: 100%;\n        margin-top: 0;\n        padding: 10px;\n    }\n\n    #chat-section {\n        width: 100%;\n        margin-top: 0;\n        padding-left: 10px;\n        padding-right: 10px;\n    }\n\n    .input-area {\n        height: auto;\n        flex-direction: column;\n    }\n\n    #user-input {\n        width: 100%;\n        height: auto;\n        min-height: 50px;\n        margin-bottom: 10px;\n    }\n\n    #send-button {\n        width: 100%;\n        padding: 12px;\n    }\n\n    .message .content {\n        max-width: 100%;\n    }\n}\n\n/* Media query per schermi con larghezza massima di 480px (smartphone) */\n@media screen and (max-width: 480px) {\n    header h1 {\n        font-size: 18px;\n    }\n\n    #send-button {\n        font-size: 16px;\n        padding: 10px;\n    }\n\n    .message .content {\n        font-size: 14px;\n    }\n\n    #new-conversation {\n        font-size: 14px;\n        padding: 8px;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n.highlighted-text {\n    font-weight: bold;\n    font-size: 1.1em; /* Aumenta la dimensione del testo del 10% */\n}\n\n\n\n\n.separator {\n    height: 1px;\n    background-color: #ccc;\n    margin: 10px 0;\n}\n\n\n\n\n.message-title {\n    margin: 10px 0;\n    font-weight: bold;\n    font-style: italic;\n}\n\n/* Titolo di livello 3 (###) - il pi\u00f9 PICCOLO */\n.title-level-3 {\n    font-size: 1.18em; /* Aumenta la dimensione del 40% */\n}\n\n/* Titolo di livello 2 (##) */\n.title-level-2 {\n    font-size: 1.28em; /* Aumenta la dimensione del 30% */\n}\n\n/* Titolo di livello 1 (#) */\n.title-level-1 {\n    font-size: 1.38em; /* Aumenta la dimensione del 20% */\n}\n\n\n\n\n/* Stile per il testo in corsivo */\n.content em {\n    font-style: italic;\n}\n\n\n.inline-code {\n    font-family: monospace;\n    background-color: #f0f0f0;\n    padding: 2px 4px;\n    border-radius: 4px;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n.model-selector {\n    position: absolute;\n    top: 10px;\n    right: 20px;\n    display: flex;\n    align-items: center;\n}\n\n.model-selector label {\n    color: white;\n    margin-right: 5px;\n    font-size: 14px;\n}\n\n.model-selector select {\n    padding: 4px 8px;\n    border: none;\n    border-radius: 4px;\n    font-size: 14px;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* Stili per il Pulsante di Anteprima */\n.preview-button {\n    position: absolute;\n    right: 25px; /* Posiziona accanto al pulsante di eliminazione */\n    top: 50%;\n    transform: translateY(-50%);\n    background: none;\n    border: none;\n    color: #e4e6eb;\n    font-size: 16px;\n    cursor: pointer;\n    opacity: 0.7;\n}\n\n.preview-button:hover {\n    opacity: 1;\n}\n\n/* Modal Styles */\n.modal {\n    display: none; /* Nascondi di default */\n    position: fixed; /* Rimani in posizione */\n    z-index: 1000; /* Sovrapponi al resto */\n    left: 0;\n    top: 0;\n    width: 100%; /* Larghezza completa */\n    height: 100%; /* Altezza completa */\n    overflow: auto; /* Abilita lo scroll se necessario */\n    background-color: rgba(0,0,0,0.4); /* Sfondo nero con opacit\u00e0 */\n}\n\n.modal-content {\n    background-color: #fefefe;\n    margin: 10% auto; /* Centra verticalmente */\n    padding: 20px;\n    border: 1px solid #888;\n    width: 80%; /* Larghezza del modal */\n    max-height: 80%;\n    overflow-y: auto;\n    border-radius: 8px;\n}\n\n.close-button {\n    color: #aaa;\n    float: right;\n    font-size: 28px;\n    font-weight: bold;\n    cursor: pointer;\n}\n\n.close-button:hover,\n.close-button:focus {\n    color: black;\n    text-decoration: none;\n}\n\n#preview-messages .message {\n    margin-bottom: 10px;\n}\n\n#preview-messages .message.user .content {\n    background-color: #0B93F6;\n    color: white;\n    border-bottom-right-radius: 0;\n}\n\n#preview-messages .message.assistant .content {\n    background-color: #E5E5EA;\n    color: black;\n    border-bottom-left-radius: 0;\n}\n\n\n\n\n\n\n\n\n/* Stile per il messaggio evidenziato */\n.highlighted-message {\n    outline: 2px solid #ff9800;\n    background-color: #fff3e0;\n}"
        }
    ]
}